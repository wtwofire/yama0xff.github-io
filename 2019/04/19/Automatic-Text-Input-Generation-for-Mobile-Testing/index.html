<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="二进制安全研究"><meta name="keywords" content="binary security，vulnerability，fuzzing, revese,二进制安全，漏洞，逆向，恶意样本检测"><title>Automatic Text Input Generation for Mobile Testing | yama0xff's blog</title><link rel="stylesheet" type="text/css" href="//fonts.neworld.org/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Automatic Text Input Generation for Mobile Testing</h1><a id="logo" href="/.">yama0xff's blog</a><p class="description">CYBERSECURITY  BETWEEN 0 AND 1</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Automatic Text Input Generation for Mobile Testing</h1><div class="post-meta"><a href="/2019/04/19/Automatic-Text-Input-Generation-for-Mobile-Testing/#comments" class="comment-count"></a><p><span class="date">Apr 19, 2019</span><span><a href="/categories/论文/" class="category">论文</a><a href="/categories/论文/fuzzing/" class="category">fuzzing</a><a href="/categories/论文/fuzzing/机器学习/" class="category">机器学习</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>已经提出许多设计来改进自动化移动手机测试。尽管有这些改进，但提供适当的文本输入仍然是一个突出的障碍，这阻碍了大规模采用自动化测试方法。关键的挑战是如何在用例上下文中自动生成最相关的文本。例如，应在移动浏览器应用程序的地址栏中输入有效的网站地址，以继续测试应用程序;应在音乐推荐应用的搜索栏中输入歌手的姓名。如果没有正确的文本输入，测试将会卡住。我们提出了一种新颖的基于深度学习的方法来应对挑战，将问题简化为最小化问题。另一个挑战是如何使该方法通常适用于受过训练的应用程序和未经训练的应用程序。我们利用Word2Vec模型来应对挑战。我们已经将我们的方法构建为工具，并使用包括Firefox和Wikipedia在内的50种iOS移动应用程序对其进行评估。结果表明，我们的方法明显优于现有的自动文本输入生成方法。</p>
<table>
<thead>
<tr>
<th>relevant information</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><em>作者</em></td>
<td>Peng Liu, Xiangyu Zhang, Marco Pistoia, Yunhui Zheng, Manoel Marques and Lingfei Zeng</td>
</tr>
<tr>
<td><em>单位</em></td>
<td>IBM T. J. Watson Research Center, Yorktown Heights, New York, USA</td>
</tr>
<tr>
<td><em>出处</em></td>
<td>2017 IEEE/ACM 39th International Conference on Software Engineering</td>
</tr>
<tr>
<td><em>原文地址</em></td>
<td><a href="https://dl.acm.org/citation.cfm?id=3097445" target="_blank" rel="noopener">https://dl.acm.org/citation.cfm?id=3097445</a></td>
</tr>
<tr>
<td><em>源码地址</em></td>
<td><a href="https://github.com/dkhamsing" target="_blank" rel="noopener">https://github.com/dkhamsing</a></td>
</tr>
<tr>
<td><em>发表时间</em></td>
<td>2017年</td>
</tr>
</tbody>
</table>
<h1 id="I-简介"><a href="#I-简介" class="headerlink" title="I. 简介"></a>I. 简介</h1><p>移动设备已成为我们生活中不可或缺的一部分。移动应用程序是提供各种便捷和高质量服务的工具，例如网页浏览，娱乐，交通信息辅助，银行和社交网络。为了满足日益增长的需求，移动市场正以每天1000多个新应用的速度快速增长[1] [6]。因此，开发团队一直处于激烈的竞争中，在发布截止日期前面临巨大的压力。遗憾的是，这通常会导致移动应用程序中的错误，例如运行时应用程序崩溃，UI设计中的缺陷以及未完全实现的功能。</p>
<p>移动测试的目标是在应用程序发布之前发现它们中的错误。有两种主流的移动测试方法：手动测试和自动monkey测试。在手动测试中，测试人员手动执行操作以尽可能多地运用用例。这种方法的缺点是需要大量的人力，因为测试人员需要在整个测试期间与应用程序密切交互。此外，通常专注于演示常见用例中的功能的人类测试人员可能经常会错过可能触发异常的极端情况。</p>
<p>自动化monkey测试[8]，[28]，[18]，[19]，[37]，[21]，[20]，[24]，[27]被提议用于减少人类的努力并最大化用例覆盖率。 “monkey”是描述这种测试如何运作的隐喻;像monkey一样，该工具执行随机动作序列，包括单击UI视图（或UI屏幕）上的按钮并执行随机击键。为了涵盖尽可能多的动作序列，研究人员提出了各种新颖的搜索算法，与monkey随机搜索策略形成对比。尽管有这些改进，但在monkey测试期间提供适当的文本输入仍然是一个突出的障碍，这阻碍了monkey测试方法的大规模采用。在许多用例中，大多数现有技术很难提供有意义的文本输入。例如，对于电影应用程序，monkey测试几乎无法提供有意义的输入，例如星际迷航。相反，它会产生不相关的输入，如4t6。因此，没有找到任何结果，从而使Monkey无法前往显示适当结果的屏幕。手动规范可以缓解这个问题，但需要大量的人力。</p>
<p>在本文中，我们提出了一个解决方案，让Monkey自动生成相关的文本输入。有了这样的输入，Monkey可以通过长动作序列进入工作流深处的UI屏幕（简称深UI屏幕），而不是一开始就卡住。一旦它到达深度UI屏幕，Monkey可以应用其他面向bug披露的测试技术，例如基于搜索的测试[26]，符号测试生成[22]，甚至是随机测试[34]来识别复杂工作流中的错误。</p>
<h2 id="A-生成相关输入"><a href="#A-生成相关输入" class="headerlink" title="A.生成相关输入"></a>A.生成相关输入</h2><p>输入生成的关键要求是生成与上下文相关的输入。<br>$$<br>Movie -&gt; search -&gt; star trek<br>$$</p>
<p>$$<br>Weather -&gt; search -&gt; New York<br>$$</p>
<p>在用例1中，在单击标记为“电影”的菜单项并且触发了标记为“搜索”的搜索栏后，应用程序将需要用户的电影标题。因此，输入星际迷航是相关的;在用例2中，单击标记为“天气”的菜单项并触发标记为“搜索”的搜索栏后，应用程序将使用该用户的城市名称。因此输入纽约是相关的。相反，在一个上下文中相关的输入可能在不同的上下文中不相关。例如，单击菜单项Weather时，输入Star Trek将不合适。我们还在第七节中将读者引用到更真实的例子中。</p>
<p><strong>挑战</strong>。上述要求对自动文本输入生成提出了很大的挑战。首先，相关性特定于自然语言语义，只有人类测试者才能理解。因此，传统的自动输入生成方法，例如基于符号执行的测试[22]，是不适用的。其次，包含确定相关文本输入的信息的动作（例如，点击菜单项电影或天气）可能不会立即在动作序列中的输入动作之前。因此，维护和查找文本输入与紧接在先行动的信息之间的映射是一种难以奏效的方法。</p>
<p><strong>我们的深度学习方法</strong>。我们提出了一种新颖的基于深度学习的方法来解决上述挑战。在高层次上，我们的解决方案包括两个阶段：在训练阶段，monkey学习测试人员的手动输入并统计地将他们与上下文相关联，例如行动历史和文本框标签;在预测阶段，monkey根据观察到的上下文自动预测文本输入。我们的方法的核心是递归神经网络（RNN）模型。这种类型的模型在许多自然语言处理（NLP）应用程序中取得了巨大成功，例如机器翻译和输入法自动完成。以输入法自动完成为例，RNN模型将单词之间的语义连接量化为非线性函数，其中参数用大的文本语料库进行训练。给定一个词，非线性函数计算其旁边的单词的概率分布，然后从分布中采样下一个单词。此外，RNN模型保持存储器状态以汇总来自先前单词的重要信息，并在推荐下一单词时将其用作另一输入源。据我们所知，我们是第一个将深度学习应用于自动测试移动设备的文本输入生成问题的人。</p>
<p>根据Mikolov等人的实证研究 [32]，RNN模型比传统的统计模型（如n-gram模型和隐马尔可夫模型）更精确。具体而言，与传统模型相比，RNN导致18％的误差减少，假设它们在相同的数据上训练，并且即使传统模型训练的数据比RNN模型多5倍，也导致12％的误差减少。</p>
<h2 id="B-与应用无关的输入生成"><a href="#B-与应用无关的输入生成" class="headerlink" title="B.与应用无关的输入生成"></a>B.与应用无关的输入生成</h2><p>输入生成的另一个重要要求是应用独立性。这意味着在一组应用程序上训练的RNN模型也应该适用于其他应用程序。</p>
<p><strong>挑战</strong>。在不同的应用程序中使用不同的单词来表示相同的概念对应用程序独立性提出了重大挑战。<br>$$<br>Film -&gt; search -&gt; ?<br>$$<br>假设在训练阶段没有看到标签Film。人类测试人员可以很容易地找出用例1中标签movie和film之间的语义相似性。因此，我们可以预测相关的文本输入 - 例如，星际迷航。然而，RNN模型完全忽略了标签film，因为它没有出现在训练阶段。因此，RNN模型无法预测标签Film的相关文本输入。</p>
<p><strong>我们基于Word2Vec的解决方案</strong>。我们通过从Google新闻语料库统计学习同义词的人类知识来应对挑战。同义词存储在等价类中。每个等价类的代表用于替换训练和预测期间属于该类的单词。</p>
<p>我们的方法建立在Word2Vec模型的基础上，这是NLP研究人员最近提出的统计模型。该模型将一个单词映射到一个向量，向量之间的距离测量单词的相似性。 Word2Vec模型通过求解优化问题来学习矢量编码。具体而言，它最小化相似单词之间的距离，并最大化不相关单词之间的距离。 Word2Vec是一种无监督学习算法，这意味着它不需要手动标记训练数据。Word2Vec在结果质量方面优于其他现有模型[33]。这主要是因为Word2Vec可以训练比先前工作多2到3个数量级的数据，而这只是之前工作所需时间的一小部分。</p>
<p>我们已经构建了一个工具，并使用50个iOS应用程序对其进行评估，包括Firefox和Wikipedia等热门应用程序。评估结果证实了我们的方法的有效性。</p>
<p>RNN预测平均将Monkey测试的覆盖率提高了21％，而RNN模型和Word2Vec模型的组合将覆盖率提高了28％。<br>此外，如果我们排除基准套件中可用UI屏幕很少的简单应用程序，我们发现RNN预测可将覆盖率提高46％，两种模型的组合可提高60％。同样重要的是，我们的预测非常有效，通常在1毫秒内完成。</p>
<p>总之，我们在本文中做出以下贡献：</p>
<ul>
<li>我们提出了一种基于深度学习的新方法，以自动生成移动UI测试的相关文本输入。</li>
<li>我们提出了Word2Vec NLP模型的新颖组合，以及使输入生成应用独立的学习。</li>
<li>我们已将我们的方法作为一个系统实施，并对包括Firefox和Wikipedia在内的50个iOS应用程序进行了实验。结果表明，我们的方法显着增加了Monkey测试的覆盖范围。</li>
</ul>
<h1 id="II-系统设计概述"><a href="#II-系统设计概述" class="headerlink" title="II.系统设计概述"></a>II.系统设计概述</h1><p>系统设计如图1所示。monkey测试引擎通过单击屏幕上的按钮来探索移动应用程序。当遇到文本框时，它会从文本输入服务器请求相关输入，如1、2所示。服务器通过进一步将其分派给人工测试人员或RNN运行实例来解析请求，该实例对应于两种模式：手动模式和AI模式。在手动模型中，在收到帮助请求3后，人工测试人员可以输入与上下文相关的文本输入4。如果她认为上下文不符合实际中的任何动作序列，则忽略它。然后，由测试者录入的输入和相应的上下文记录在与服务器相关联的数据库中。在AI模式中，我们首先使用记录在数据库5中的训练数据集训练RNN模型，之后RNN实例可以自动预测文本输入6。</p>
<p><img src="/2019/04/19/Automatic-Text-Input-Generation-for-Mobile-Testing/1.jpg" alt=""></p>
<p>在预测阶段6中，Monkey利用RNN模型来预测给定上下文中的文本输入值。基本上，考虑到Monkey测试引擎维护的上下文，模型预测文本输入值。但是，由于我们预测输入的应用程序与我们训练模型的应用程序不同，因此RNN模型可能无法识别Monkey测试期间遇到的某些上下文信息。为了解决这一挑战，我们使用Word2Vec模型改进了RNN模型，该模型有助于识别语义相似的上下文，尽管它们具有不同的句法形式（例如，“moive”和“film”）。通过RNN模型和Word2Vec模型的新颖组合，我们有效地解决了这个问题。</p>
<p>在下文中，我们首先介绍第III节中的背景，然后解释我们如何应用深度学习技术来自动预测第IV节中的文本输入。<br>在第五节中，我们将解释实现细节。在第六节中，我们讨论了这项工作的假设。第七节介绍评估结果。</p>
<h1 id="III-背景深度介绍"><a href="#III-背景深度介绍" class="headerlink" title="III. 背景深度介绍"></a>III. 背景深度介绍</h1><p>本节介绍了递归神经网络（RNN）和Word2Vec的背景。 RNN和Word2Vec都是神经网络的特殊形式。为了讨论这两个，我们首先要简要介绍一下神经网络。</p>
<p><img src="/2019/04/19/Automatic-Text-Input-Generation-for-Mobile-Testing/2.jpg" alt=""></p>
<p>神经网络（NN）有两种形式：图形形式和数学形式。在图形形式（图2a）中，NN具有输入层，输出层，一个或多个隐藏层。每个层（输入层除外）包括多个神经元，它们与前一层和下一层中的神经元相连。</p>
<p>每个神经元，如图2b所示，是一个基本的计算单元。它首先将沿着传入边传递的值线性组合为∑ ~i~ p~i~x~i~ + b，其中p~i~和b是要训练的参数。然后它应用激活函数f~a~，例如tanh函数[12]或sigmoid函数[11]。激活函数对于使神经元非线性非常重要。<br>没有激活函数，神经元仅仅是线性函数，神经网络也是线性函数，不能表征许多复杂模型。</p>
<p>在数学形式中，NN是由神经元代表的函数的组合。设f：R^n^→R^m^表示由神经网络表示的复合函数。设输入向量I∈R^n^表示输入层中n个神经元的输入。设输出向量O∈R^m^表示输出层中m个神经元的输出。神经网络的训练可以被视为一个优化问题：</p>
<p><img src="/2019/04/19/Automatic-Text-Input-Generation-for-Mobile-Testing/3.jpg" alt=""></p>
<p>更新参数以最小化预测输出和训练数据集上的实际输出之间的总损失，其中损失函数可以被定义为距离或其他形式。无论损失函数的复杂性如何，梯度下降算法[16]通常用于最小化其值。</p>
<p>A.递归神经网络</p>
<p>RNN是一种特殊形式的神经网络，具有反馈回路，如图3所示。为清楚起见，我们使用箭头来表示神经元之间的连接。</p>
<p><img src="/2019/04/19/Automatic-Text-Input-Generation-for-Mobile-Testing/4.jpg" alt=""></p>
<p>循环允许在网络执行步骤中导出的信息传递到下一个，类似于人类的长期记忆。图4显示了概念上展开的版本，其中神经网络在概念上被复制以通过多个步骤服务于一系列输入。</p>
<p><img src="/2019/04/19/Automatic-Text-Input-Generation-for-Mobile-Testing/5.jpg" alt=""></p>
<p>注意神经网络副本之间的连接。 RNN考虑输入法自动完成的应用，我们应用RNN生成句子“how are you doing”。这些单词一个接一个地输入到输入层。每个字在单热矢量表示中被编码以使得能够学习，例如，单词“how”被编码为[1,0,0,0]。简单地说，向量的每个条目对应于词汇表中的单词（[“how”，“are”，“you”，“doing”]），向量中值1的位置表示编码的单词。从概率的角度来看，向量表示具有100％概率的单词，而其他概率表示具有0％概率的单词。</p>
<p>利用初始参数设置，给定输入字与从最后一步传递的信息相结合，神经网络输出概率向量，其中第i个条目估计词汇表中的第i个单词接下来出现的概率。例如，基于输入“how”，假设它将下一个词预测为[0.4,0.2,0.1,0.3]，即，最可能的下一个词是“how”。但是，我们从训练数据集中观察到下一个单词应该是“are”。因此，训练算法需要更新参数，使得单词“are”的预测概率变得显着大于其他单词。同样，给定“are”这个词，神经网络需要预测“you”作为下一个词的概率高于其他词。 </p>
<h2 id="B-Word2Vec"><a href="#B-Word2Vec" class="headerlink" title="B.Word2Vec"></a>B.Word2Vec</h2><p>Word2Vec算法学习空间R^k^中每个单词的向量表示，其中相似的单词可能具有相似的向量。 Word2Vec通常应用于非常大的语料库。为了获得更好的可扩展性，Word2Vec采用传统的神经网络结构。</p>
<p>Word2Vec采用的矢量表示与上述RNN中使用的单热表示明显不同。 Word2Vec将每个单词映射到空间R^k^中的实值向量，其中k远小于词汇量s，而单热表示将每个单词映射到空间{0,1}^s^中的向量。首先，通过在低维空间中编码矢量，Word2Vec降低了计算的空间复杂度。更重要的是，Word2Vec的矢量表示处于连续空间中，并且两个矢量之间的距离（即，余弦相似距离）有效地测量了单词的相似性。相反，单热表示不能测量相似性。在我们的工作中，我们将Word2Vec视为黑盒子。</p>
<h1 id="IV-将深度学习应用于输入生成"><a href="#IV-将深度学习应用于输入生成" class="headerlink" title="IV.将深度学习应用于输入生成"></a>IV.将深度学习应用于输入生成</h1><p>在高级别，我们的方法在统计学上学习文本输入值与训练阶段的上下文之间的相关性（第IV-B节）。然后是预测阶段（第IV-C节），一旦Monkey需要在文本框中提供某些值，我们的方法就会根据Monkey目前观察到的上下文来预测值。第IV-D节进一步解释了我们如何推广输入生成以使其独立于应用程序。为便于讨论，我们首先介绍在训练阶段使用的训练数据集（第IV-A节）。</p>
<h2 id="A-训练数据集"><a href="#A-训练数据集" class="headerlink" title="A.训练数据集"></a>A.训练数据集</h2><p>在不失一般性的情况下，我们假设简化的用户行为模型。在模型中，我们只对两种类型的UI元素感兴趣：按钮和文本框∈domain T~ui~。各种可点击的UI元素（如菜单和tableview单元格）具有类似于按钮的行为，因此在我们的模型中具有相同的抽象。类似地，接受用户输入的一系列文本字段（例如安全文本字段和搜索字段）被抽象为文本框。请注意，我们的实现完全支持所有这些UI元素。我们只对两种类型的动作感兴趣，tap和typeText∈T~action~，它们是UI元素∈T~ui~的最具代表性的行为。</p>
<p>用户动作α∈A是一个元组，包括UI元素类型τ~ui~∈T~ui~，动作类型τ~action~∈T~action~、显示在UI元素中的标签 δ（例如，图5中的按钮中的“Moive”），以及在动作中涉及的可选值v，例如文本输入值。</p>
<p>训练数据集基本上记录了动作序列（α~0~，α~1~，….  ，α~n~），其中α~i~表示在第i步的用户动作。 α~n~之前的子序列指的是用户到达发生α~n~的UI屏幕所采取的动作。有关动作序列的更多细节将在第VI节中讨论。</p>
<p>我们观察到标签δ是用户在使用应用程序时所感知的最突出的信息，考虑提供什么作为输入值。基于这种观察，我们用动作序列中的每个动作α表示标签δ~α~，同时抽象掉所有其他信息。此外，我们还对在动作α~n~中输入的输入值v~αn~感兴趣。因此，上述动作序列简单地表示为（δα~0~，δα~1~，…. ，δa~n~，va~n~ ）.为了便于演示，我们还提到δα~0~，δα~1~，…. ，δa~n~作为输入值vα~n~的上下文。</p>
<p><img src="/2019/04/19/Automatic-Text-Input-Generation-for-Mobile-Testing/6.jpg" alt=""></p>
<p>考虑图5中的示例，假设测试人员执行操作以触发UI屏幕转换并输入输入值。在第一个屏幕中，测试人员点击（或点击）标有“Moive”的按钮，通向第二个屏幕，搜索栏标有“搜索”。在第三个屏幕中，测试仪在搜索栏中输入输入值“Star Trek”。<br>在用户操作模型之后，我们有两个操作：单击带有标签Movie的按钮，然后在搜索栏中输入带有标签Search的“Star Trek”。因此，记录的序列是“Moive”，“search”，“star Trek”。 </p>
<h2 id="B-训练阶段"><a href="#B-训练阶段" class="headerlink" title="B.训练阶段"></a>B.训练阶段</h2><p>不失一般性，我们假设每个标签δ或输入值v是单个单词，而不是短语。第VI节介绍了一种确保假设的简单预处理。</p>
<p>设Vocabulary V =L∪Val表示训练数据集中出现的所有标签和输入值的列表。在下文中，除非另有说明，否则我们不区分标签和输入值。相反，我们用一般术语词来引用它们。</p>
<p>为了实现学习，我们提出了每个单词的以下向量表示。给定单词ω，其矢量形式ω‘具有与词汇相同的大小。并且向量的每个条目被定义为，</p>
<p><img src="/2019/04/19/Automatic-Text-Input-Generation-for-Mobile-Testing/7.jpg" alt=""></p>
<p>因为只有一个条目可以取值1，所以向量表示也被称为单热表示。考虑图4.在步骤2，输入向量为[0,1,0,0]，如输入层所示。</p>
<p>在每个步骤，RNN模型接受单词的向量表示作为输入。输入以及隐藏层的先前状态（也被编码为矢量）用于预测输出，该概率矢量表征序列中接下来出现的每个单词的概率。训练的目标是更新RNN模型的参数，使得下一个词的预测概率分布接近从数据集观察到的真实概率分布。</p>
<p>我们将训练正式化为优化问题：</p>
<p><img src="/2019/04/19/Automatic-Text-Input-Generation-for-Mobile-Testing/8.jpg" alt=""></p>
<p>给定上下文δα~0~，δα~1~，….，δa~n~，我们找到具有最大条件概率的输入值vα~n~= x。在训练阶段，我们建立一个RNN模型来预测条件概率。自动计算模型的内部参数，以使预测的概率分布近似于从训练数据集中观察到的真实概率分布。然后，在假设上下文与文本框的输入值之间的概率关联没有显着改变的情况下，将训练的模型用于预测。我们在网站上解释了有关形式化的更多细节[4]。</p>
<h2 id="C-预测阶段"><a href="#C-预测阶段" class="headerlink" title="C.预测阶段"></a>C.预测阶段</h2><p>训练模型后，可以将其用于预测。通常，RNN模型接受一系列单词作为输入，并输出概率向量，该概率向量表征词汇表中的每个单词紧接在序列之后出现的概率（我们称之为下一个单词）。概率分布的采样将选择具有分布中描述的概率的单词。</p>
<p>在我们的问题设置中，当Monkey遇到文本框时，它会将动作历史记录和文本框的标签序列化为序列，然后将序列发送到训练模型以预测下一个单词的概率分布。最后，它对概率分布进行采样以获得下一个单词的值。</p>
<p>通常，词汇表中的任何单词都可以是下一个单词。词汇表中的单词可以对应于动作标签，文本框标签或文本输入值，但我们只对预测文本输入值感兴趣。如果采样结果不表示文本输入值（即，它不属于文本输入值的词汇表），我们将其丢弃并重新对分布进行采样。</p>
<p>对概率分布进行采样的想法如下。令o’ 表示RNN模型的输出向量，其表征概率分布。我们首先将0到1之间的范围分成| o ‘|间隔。区间i（0 ≤ i &lt;| o ‘|）从<img src="/2019/04/19/Automatic-Text-Input-Generation-for-Mobile-Testing/9.jpg" alt="">开始并以<img src="/2019/04/19/Automatic-Text-Input-Generation-for-Mobile-Testing/10.jpg" alt="">结束。均匀随机变量X~U（0,1）落入具有概率o’ [i]的区间，即区间的长度。换句话说，均匀随机变量X落入区间i的概率与我们选择单词＃ -  V [i]的概率相同。因此，如果随机变量落入区间i，我们返回单词V’ [i]。</p>
<p>请考虑以下示例。假设输出概率向量为[0.1,0.7,0.1,0.1]，如图4所示。图6显示了四个间隔。假设均匀随机变量的值为0.5，则它落入区间1（注意区间为0）。因此，我们返回单词V’ [1]，即单词“are”。</p>
<p><img src="/2019/04/19/Automatic-Text-Input-Generation-for-Mobile-Testing/11.jpg" alt=""></p>
<h2 id="D-独立于应用程序的输入生成"><a href="#D-独立于应用程序的输入生成" class="headerlink" title="D.独立于应用程序的输入生成"></a>D.独立于应用程序的输入生成</h2><p>我们的最终目标是预测我们尚未接受过训练的应用程序的输入。主要挑战是使输入生成应用独立。</p>
<p>我们的想法是，如果我们遇到一个在训练阶段没有看到的单词，我们可以将它连接到在训练阶段看到的一些类似的单词，利用Word2Vec。我们使用预先使用非常大的Google新闻语料库训练的Word2Vec模型。当遇到不在词汇表中的单词时，例如，在训练期间没有出现在任何应用程序中的文本框标签时，我们的系统会查询Word2Vec以查找词汇表中最相似的单词（更确切地说，词汇表动作标签和文本框标签）。如果可以从两个单词的矢量表示计算的相似度低于预设阈值0.7，则我们认为该单词在训练数据集中没有对应物并且在预测期间简单地忽略它。在最坏的情况下，如果这个词在确定文本输入值时很重要，那么我们的技术就会降低到传统的Monkey测试。这些情况的发生主要是因为应用程序属于一个与我们训练过的应用程序类型非常不同的新类别。</p>
<h1 id="V-实现"><a href="#V-实现" class="headerlink" title="V.实现"></a>V.实现</h1><p>我们在第II节中介绍了系统设计的概述。在本节中，我们将解释图1中所示的每个组件的实现细节。</p>
<p><strong>a）Monkey测试引擎</strong>：我们的monkey在探索动作序列时采用深度优先搜索策略，即在填充当前屏幕中所有文本框元素的值之后逐个点击可用按钮。可以以随机顺序或以某种顺序（例如，按钮标签的字母顺序）单击同一屏幕内的按钮。我们实现了两个选项并在我们的实验中采用了随机顺序。另外，为了避免重复探索同一个屏幕，我们构建了每个屏幕的签名，其中包括屏幕标题和屏幕中按钮的标签。具有相同签名的屏幕被视为同一屏幕，仅被探索一次。</p>
<p>请注意，除文本输入外，我们的系统还可以轻松扩展以预测下一步操作。然而，我们认为这会不利地限制Monkey实现良好覆盖的能力，因为它往往会跟随人类测试者的动作序列，这些动作序列是有限的。因此，我们系统的一个重要设计原则是使用随机探索动作和RNN预测文本输入。</p>
<p>我们使用Xcode IDE附带的测试自动化框架XCTest实现了iOS Monkey。该框架提供了一组API [9]，允许我们在屏幕中找到按钮或文本框元素。例如，我们可以使用以下API调用轻松找到当前屏幕中的所有按钮：</p>
<p>descendantsMatchingType（.Button）</p>
<p><strong>b）文本输入服务器</strong>：使用python web框架Bottle [2]实现的文本输入服务器是一个隐藏了如何生成输入的详细信息的抽象层。由于它是用Python实现的，而Monkey测试引擎是在Swift中实现的，因此两个组件之间存在编程语言障碍。为了打破障碍，他们通过以JSON格式发送HTTP消息来相互通信。输入服务器通过函数调用与RNN实例通信，因为它们都是用Python实现的。此外，我们为输入服务器维护了一个数据库，用于存储人类测试人员在某些上下文中输入的输入。我们采用了MongoDB [7]。输入服务器使用Python驱动程序PyMongo [10]与数据库交互。</p>
<p><strong>c）RNN实例</strong>：我们在Python深度学习框架Tensorflow [13]之上构建了RNN模型，它提供了高级API，同时隐藏了许多低级细节。通过Tensorflow的抽象，可以使用仅40行代码构建RNN模型，如我们的网站[3]所示。我们通过首先使用Word2Vec预处理数据集然后将它们输入RNN模型来训练模型。此外，经过训练的RNN模型可以保存到磁盘上并随时加载以供进一步使用。</p>
<h1 id="VI-讨论"><a href="#VI-讨论" class="headerlink" title="VI.讨论"></a>VI.讨论</h1><p>在本节中，我们将讨论我们在这项工作中所做的假设。<br>我们在训练/预测中做出的假设是标签或输入值是单个单词，而不是短语或句子。如果标签确实是一个短语，我们将其分解为单词并将每个单词视为单独的标签上下文。通过在单词级别推理，只要其中的单词属于我们的词汇表，我们的方法就可以处理任何短语。相反，对于作为短语的文本输入值，我们将短语视为原子单位，以便在整个训练和预测期间不对它们进行分区。</p>
<p>我们的方法的另一个重要假设是我们训练Monkey的应用程序和Monkey将测试的应用程序应该分享一些相似性，例如，它们属于App市场上的相同类别。否则，如果我们在娱乐应用程序上训练Monkey并将其应用于测试Tax应用程序，那么预测的文本输入将毫无意义。为了避免这种情况，我们收集尽可能多的不同类型的应用程序，并将它们用作训练主题。</p>
<p>在我们的方法中，我们假设上下文仅包含文本标签。在真实世界的应用程序中，开发人员可能会使用图标而不是文本标签。我们目前不支持非文字标签。我们注意到我们的方法可以扩展到支持非文本标签，例如，利用image2text工具[14]。</p>
<p>当我们记录动作序列时，我们维护一个列表并将每个动作附加到列表中。但是，如果我们遇到撤消上一个操作的操作，我们会放弃操作并从列表中删除上一个操作;如果我们遇到导致应用程序主屏幕的操作，我们只需清除列表即可。最后，我们的工作补充了自动行动序列生成的大量最新进展[28]，[24]，[27]。虽然我们期待很大的协同作用，但我们将把它留给我们未来的工作。</p>
<h1 id="七-评估"><a href="#七-评估" class="headerlink" title="七.评估"></a>七.评估</h1><p>在我们的实验中，我们对以下研究问题感兴趣：</p>
<ul>
<li>与其他用于移动测试的自动输入生成方法相比，我们的自动化方法的效果如何？</li>
<li>与仅使用RNN模型相比，Word2Vec是否允许更好的结果？</li>
<li>我们的工具产生的性能开销是多少？</li>
</ul>
<p>为了解决第一个问题，我们与自动随机输入生成方法进行比较，该方法从常用输入值池中随机选择[30]输入值。</p>
<p>我们通过计算屏幕覆盖率来测量有效性，即，在固定时间窗口内已经探索了多少不同的UI屏幕。通常采用monkey测试来探索尽可能多的用例。但是，识别独特的用例需要领域知识。相反，我们使用屏幕覆盖来客观地估计用例覆盖范围。</p>
<p>请注意，屏幕覆盖范围与功能测试中的经典覆盖标准（例如，语句覆盖率和路径覆盖率）不同。我们认为两者都很重要。特别是，我们的方法补充了功能测试，因为通过提供有意义的输入值，我们的技术允许Monkey访问有趣的UI屏幕。从这样的UI屏幕开始，可以应用现有的功能测试工作来暴露应用程序崩溃。此外，我们认为一些UI屏幕很有趣，即使它们与任何应用程序崩溃都不对应。我们将读者引用到我们的网站[5]以获取此类示例。</p>
<p>请注意，我们的方法与自动事件序列生成方法正交。在这项工作中，我们采用现有的深度优先搜索策略。我们的贡献主要在于根据上下文生成相关的文本输入，并容忍在不同的应用程序中使用不同的单词。</p>
<p>为了解决第二个研究问题，我们比较了仅启用RNN的版本以及启用了RNN和Word2Vec的版本。第VII-B节通过将三个版本比较在一起来解决上述两个问题。</p>
<p>最后，性能开销很重要，特别是考虑到在Monkey测试期间交互式预测。理想情况下，该方法应该以低性能开销实现有效性。性能的测量见第VII-A节。</p>
<p>  a）实验设置：我们在OS X EI Capitan的MacBook Pro上进行实验。 iOS应用程序在iPhone 6S Plus（iOS 9.2）的模拟器中运行。我们从Github收集了200个开源iOS应用程序，主要来自https：//github.com/dkhamsing/open-source-ios-apps。它们分为不同的类别，包括电影，新闻，图像，浏览器，旅行，广播，日历，天气和任务。它们包括流行的应用程序，如Firefox和维基百科。我们对150个应用程序进行了训练，并测试了其余50个应用程序的预测功能。</p>
<p>我们的训练数据集共包含14061个单词。当我们收集训练数据集时，我们尝试尽可能多地重用输入值。例如，当我们需要在不同的应用程序中输入电影名称时，我们会坚持使用相同的电影名称。</p>
<h2 id="A-性能开销"><a href="#A-性能开销" class="headerlink" title="A.性能开销"></a>A.性能开销</h2><p>学习/训练过程需要多次迭代。我们用于预测的模型训练了6个小时，但我们在更短的时间内测量了性能。我们测量每1000次迭代的计算时间并报告迭代的平均时间。我们还使用每1000次迭代后生成的模型，使用数据集中的随机序列预测下一个单词。这是为了抽样模型的准确性。我们还测量RNN模型用于训练和预测的时间。如图7所示，除初始步骤外，训练/预测时间保持不变。这是因为每次迭代处理固定数量的数据，并且神经网络结构不会动态变化。另一个重要的观察是每个预测平均需要0.7毫秒，与测试中的其他操作相比可以忽略不计（例如，输入文本）</p>
<p><img src="/2019/04/19/Automatic-Text-Input-Generation-for-Mobile-Testing/12.jpg" alt=""></p>
<p>我们还测量了Word2Vec模型的加载时间以及每个查询类似单词的时间。加载大约需要54秒，而每次查询大约需要0.7毫秒。由于空间限制，我们不显示数字。加载时间很长，因为模型很大，在Google新闻语料库中训练有30亿个运行单词。<br>我们的文本输入服务器通过在服务器初始化期间加载模型来解决此问题。加载后，该模型可用于所有传入的查询。</p>
<h2 id="B-我们方法的有效性"><a href="#B-我们方法的有效性" class="headerlink" title="B.我们方法的有效性"></a>B.我们方法的有效性</h2><p>为了衡量有效性，我们比较了三个版本：（1）随机，随机从常用输入值池中选取一个值。请注意，随机版本忽略了上下文信息。 （2）RNN，其应用RNN预测模型并因此知道上下文信息，（3）RNN + Word2Vec，其启用RNN预测和Word2Vec模型。</p>
<p>我们计算在5分钟内不同版本探索的屏幕数量。对于每个版本，我们重复实验三次并报告最大数量。图8中报告了50个应用程序的结果。RNN版本检测到的屏幕比随机版本多21.1％，而RNN + Word2Vec版本检测到的屏幕比随机版本多28.6％。由于有许多应用程序具有简单的功能，因此屏幕数量较少，因此这三个版本可以为这些应用程序探索相同数量的屏幕。通过排除这些情况，我们观察到RNN版本优于随机版本46％，而RNN + Word2Vec版本优于60％。请注意，RNN版本与RNN + Word2Vec版本之间的差异突出了使用Word2Vec的有效性。</p>
<p><img src="/2019/04/19/Automatic-Text-Input-Generation-for-Mobile-Testing/13.jpg" alt=""></p>
<p>我们手动检查详细结果并进行一些有趣的观察。首先，这三个版本为27个应用程序产生相同的结果。原因是这些应用程序要么不需要任何用户输入，要么使用任何类型的输入值。例如，在PropertyFinder中，即使Monkey在搜索栏中输入了无意义的输入值，该值也不会导致匹配，该应用程序仍会检索并显示待售房地产属性的列表。在另一个应用程序聊天中，该应用程序用于接收/发送消息，无论消息是什么，它都可以正常工作。</p>
<p>其次，我们观察到RNN版本可以探索随机版本无法探索的许多UI屏幕。直观地，当文本框需要特殊格式或特殊含义的输入值时，RNN版本知道上下文并根据从训练数据集中学习的经验产生适当的输入值。相比之下，无视上下文的随机版本通常会产生不符合特殊要求的输入值。例如，在sip-calculator应用程序中，有一个标签为“amount”的文本框，这意味着它需要一些数字输入（即，app将对输入数字执行一些算术运算）。使用我们的RNN模型的monkey知道上下文信息并且已经知道上下文与数字输入值强烈相关。结果，Monkey输入数字输入值并进入新屏幕。相反，随机版本不会产生任何数字输入，因此无法继续。</p>
<p>在极端情况下，AlzPrevent应用程序（即研究实验室的调查应用程序）要求用户在进行调查之前填写注册表。 AlzPrevent有10个用于注册过程的屏幕，包括用户名，身高，体重和其他一些信息。随机版本卡在第一页，而我们的RNN版本（以及RNN + Word2Vec版本）知道如何填写输入值，因为它已经过多个需要注册的应用程序的训练。因此，我们的RNN版本优于随机版本112％，RNN + Word2Vec版本优于212％。</p>
<p>第三，当上下文与受过训练的应用程序中的上下文略有不同时，我们发现RNN + Word2Vec版本的性能优于RNN版本。使用Word2Vec模型，该版本识别来自不同应用程序的上下文之间的语义相似性。基于相似性信息，版本基于与来自训练的应用的上下文相关联的知识来预测相关输入值。对RNN模型的改进表明了组合RNN模型和Word2Vec模型的重要性和有效性。</p>
<p>   我们还在第VII-C节中介绍了案例研究，以展示我们技术的优势。</p>
<h2 id="C-案例研究"><a href="#C-案例研究" class="headerlink" title="C.案例研究"></a>C.案例研究</h2><p><img src="/2019/04/19/Automatic-Text-Input-Generation-for-Mobile-Testing/14.jpg" alt=""></p>
<p><strong>a）Firefox</strong>：第一个案例来自官方的Firefox iOS应用程序。这个案例说明了生成相关输入值的重要性，并说明了我们的方法如何产生它们。如图9所示，在屏幕1上，缺少主页按钮（默认情况下），因此无法测试与按钮相关的功能。要显示主页按钮，必须点击设置按钮更改设置。但是，屏幕2上的输入值需要有效的网页URL。否则主页按钮不会显示。我们的Monkey可以根据其标签“输入网页”和操作历史设置→主页（屏幕2）预测文本框的有效URL，从而启用主页按钮，如屏幕3所示。</p>
<p>随机版本忽略了文本框中的“输入网页”标签，产生随机输入值“New York”。 Firefox应用程序不接受输入，因此不启用“主页”按钮。事实上，Firefox不会在其数据库中记录无效输入。在Monkey导航到另一个屏幕然后返回之后，Random版本输入的输入值将丢失。通过在训练数据集中手动搜索预测的网页URL，我们可以识别出一些有趣的连接。该网址由网络抓取工具应用使用，并与应用中的“网站”标签相关联。我们的方法首先基于Word2Vec识别“网站”和“网页”（屏幕2）之间的相似性，然后基于RNN模型预测最可能的输入值。此示例演示了我们的技术在探索新UI屏幕方面的有效性，即使这两个应用程序具有不同的用例或业务逻辑。</p>
<p><strong>b）第三方Github应用程序</strong>：图10显示了Github的第三方应用程序的案例。在这种情况下，我们的工具点击搜索菜单项（屏幕1），然后选择存储库类别（屏幕2）。它还成功预测了搜索栏的输入值Java，这导致了一些匹配的存储库返回的进一步进展（屏幕3）。我们的工具进一步单击每个存储库，从而发现异常。</p>
<p>如图11所示，异常发生在第116行。通过使用Swift语言[15]中的感叹号，开发人员假定变量repoDescription（即存储库的描述）不能为零（即，没有值）。但是，在实践中，某些存储库没有任何描述，这打破了开发人员的假设。因此，移动应用程序在尝试解包可选值为nil时崩溃。</p>
<p><img src="/2019/04/19/Automatic-Text-Input-Generation-for-Mobile-Testing/15.jpg" alt=""></p>
<p>相比之下，随机版本产生的输入值Benjamin Franklin在当前环境中是不合适的。因此，此版本无法找到上述错误。这个案例清楚地表明了我们工具的用处。</p>
<p><strong>c）Frameless</strong>：Frameless是一款采用极简主义UI设计的全屏网页浏览器。</p>
<p><img src="/2019/04/19/Automatic-Text-Input-Generation-for-Mobile-Testing/16.jpg" alt=""></p>
<p><img src="/2019/04/19/Automatic-Text-Input-Generation-for-Mobile-Testing/17.jpg" alt=""></p>
<p>我们的工具发现了类似于Github应用程序中发现的bug的错误，如图12所示。查找错误需要Monkey测试才能生成有效的输入。考虑图13，在第一个屏幕中，搜索栏显示网站URL或搜索。鉴于这样的背景，我们的工具基于从训练数据集学习的统计相关性在第二屏幕中产生有效的网站。移动应用程序然后转换到第三个屏幕。通过单击登录按钮，我们的工具暴露了图12中所示的异常。通过检查代码，我们发现单击登录按钮会导致内部执行一些错误修复代码，遗憾的是错误处理了URL的内容。在这种情况下，上下文由四个单词组成，所有单词都被发送到RNN模型以在搜索栏中产生有效输入。相比之下，Random版本没有生成有效的URL，因此无法找到上述错误。</p>
<h1 id="八-相关工作"><a href="#八-相关工作" class="headerlink" title="八.相关工作"></a>八.相关工作</h1><p>我们的工作与Android应用程序的自动测试生成密切相关。 Monkey [8]和Dynodroid [28]是基于随机探索的UI事件生成工具。 GUIRipper [18]（MobiGUITAR [19]），ORBIT [37]，A3E [21]，SwiftHand [23]和PUMA [25]为UI构建有限状态模型并生成事件以系统地探索模型中的状态。 Contest [20]基于一种复杂的执行方法生成事件，并通过检查事件序列之间的条件来修剪搜索空间。 Ermuth和Pradel [24]介绍了宏事件，它总结了单个步骤的低级UI事件的重复序列。通过将宏事件与随机测试相结合，它们利用记录的用户交互序列并自动生成新测试。与我们的方法相比，大多数自动化测试生成工作侧重于生成事件序列（或动作序列）。</p>
<p>除了事件和意图之外，生成测试输入值也很重要，因为只有满足输入值的谓词才能暴露某些行为。还应用了基于符号执行和进化算法的技术。 JPF-Android [36]扩展了Java PathFinder（JPF），是一个模型检查工具，用于探索所有路径并识别运行时故障。 EvoDroid [29]基于进化算法框架生成测试（包括事件和输入）。它使用随机方法生成输入。 Sapienz [30]是一款基于多目标搜索的Android应用测试工具。它结合了随机模糊测试，系统和基于搜索的探索，利用种子和多级插桩。虽然它可以提供字符串作为测试输入，但是这些字符串是通过逆向工程APK从应用程序中提取的，并随机播种到文本字段中。随机选择的输入在特定上下文中不太可能相关。 Afshan等 [17]应用基于n-gram语言模型的引导搜索来产生可读字符串输入而不是随机字符序列。但是，该方法不是为在用例上下文中生成字符串输入而设计的。</p>
<p>我们的工作还涉及基于机器学习的文本建模和生成技术。 Sutskever等人 [35]通过将大量训练的RNN应用于预测文本流中的下一个字符的任务，展示了它们的强大功能。 Melicher等 [31]提出了一种基于神经网络的方法来模拟人类选择的密码并测量其对猜测攻击的抵抗力。</p>
<h1 id="IX-结论"><a href="#IX-结论" class="headerlink" title="IX.结论"></a>IX.结论</h1><p>我们已经开发了一种基于深度学习的方法来自动生成移动测试的文本输入。它在上下文中生成最相关的输入值。此外，我们利用Word2Vec模型实现了独立性。对50多个iOS应用程序的评估证实了我们设计的有效性和效率。</p>
</div><div class="tags"><a href="/tags/fuzzing/">fuzzing</a><a href="/tags/机器学习/">机器学习</a><a href="/tags/2017年/">2017年</a><a href="/tags/Word2Vec/">Word2Vec</a></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/2019/04/22/Remote-Protocol-Vulnerability-Discovery-for-Intelligent-Transportation-Systems-ITS/" class="pre">Remote Protocol Vulnerability Discovery for Intelligent Transportation Systems (ITS)</a><a href="/2019/04/18/DeepFuzz-Automatic-Generation-of-Syntax-Valid-C-Programs-for-Fuzz-Testing/" class="next">DeepFuzz: Automatic Generation of Syntax Valid C Programs for Fuzz Testing</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Abstract"><span class="toc-text">Abstract</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#I-简介"><span class="toc-text">I. 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#A-生成相关输入"><span class="toc-text">A.生成相关输入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B-与应用无关的输入生成"><span class="toc-text">B.与应用无关的输入生成</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#II-系统设计概述"><span class="toc-text">II.系统设计概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#III-背景深度介绍"><span class="toc-text">III. 背景深度介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#B-Word2Vec"><span class="toc-text">B.Word2Vec</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IV-将深度学习应用于输入生成"><span class="toc-text">IV.将深度学习应用于输入生成</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#A-训练数据集"><span class="toc-text">A.训练数据集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B-训练阶段"><span class="toc-text">B.训练阶段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-预测阶段"><span class="toc-text">C.预测阶段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#D-独立于应用程序的输入生成"><span class="toc-text">D.独立于应用程序的输入生成</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#V-实现"><span class="toc-text">V.实现</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#VI-讨论"><span class="toc-text">VI.讨论</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#七-评估"><span class="toc-text">七.评估</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#A-性能开销"><span class="toc-text">A.性能开销</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B-我们方法的有效性"><span class="toc-text">B.我们方法的有效性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-案例研究"><span class="toc-text">C.案例研究</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#八-相关工作"><span class="toc-text">八.相关工作</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IX-结论"><span class="toc-text">IX.结论</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/04/23/A-Deep-Learning-based-Approach-to-Automated-Android-App-Testing/">A Deep Learning based Approach to Automated Android App Testing</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/22/Remote-Protocol-Vulnerability-Discovery-for-Intelligent-Transportation-Systems-ITS/">Remote Protocol Vulnerability Discovery for Intelligent Transportation Systems (ITS)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/19/Automatic-Text-Input-Generation-for-Mobile-Testing/">Automatic Text Input Generation for Mobile Testing</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/18/DeepFuzz-Automatic-Generation-of-Syntax-Valid-C-Programs-for-Fuzz-Testing/">DeepFuzz: Automatic Generation of Syntax Valid C Programs for Fuzz Testing</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/17/Neural-Fuzzing-A-Neural-Approach-to-Generate-Test-Data-for-File-Format-Fuzzing/">Neural Fuzzing: A Neural Approach to Generate Test Data for File Format Fuzzing</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/17/Faster-Fuzzing-Reinitialization-with-Deep-Neural-Models/">Faster Fuzzing: Reinitialization with Deep Neural Models</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/15/Not-all-bytes-are-equal-Neural-byte-sieve-for-fuzzing/">Not all bytes are equal: Neural byte sieve for fuzzing</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/15/Recurrent-Neural-Networks-for-Fuzz-Testing-Web-Browsers/">Recurrent Neural Networks for Fuzz Testing Web Browsers</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/11/NEUZZ-Efficient-Fuzzing-with-Neural-Program-Smoothing/">NEUZZ: Efficient Fuzzing with Neural Program Smoothing</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/11/HVLearn-Automated-Black-box-Analysis-of-Hostname-Verification-in-SSL-TLS-Implementations/"> HVLearn: Automated Black-box Analysis of Hostname Verification in SSL/TLS Implementations</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/科研/">科研</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/论文/">论文</a><span class="category-list-count">34</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/论文/IOT/">IOT</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/论文/fuzzing/">fuzzing</a><span class="category-list-count">25</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/论文/fuzzing/协议/">协议</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/论文/fuzzing/可利用性判定/">可利用性判定</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/论文/fuzzing/机器学习/">机器学习</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/论文/fuzzing/测试样例生成/">测试样例生成</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/论文/fuzzing/测试输入生成/">测试输入生成</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/论文/fuzzing/测试输入筛选/">测试输入筛选</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/论文/fuzzing/综述/">综述</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/论文/fuzzing/评估/">评估</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/论文/数据挖掘/">数据挖掘</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/论文/数据挖掘/综述/">综述</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/论文/自动化利用/">自动化利用</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/论文/软件分析/">软件分析</a><span class="category-list-count">5</span></li></ul></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/ACM-CCS’18/" style="font-size: 15px;">ACM CCS’18</a> <a href="/tags/Double-Fetch-Bugs/" style="font-size: 15px;">Double-Fetch Bugs</a> <a href="/tags/2018年/" style="font-size: 15px;">2018年</a> <a href="/tags/exploitation/" style="font-size: 15px;">exploitation</a> <a href="/tags/heap/" style="font-size: 15px;">heap</a> <a href="/tags/符号执行/" style="font-size: 15px;">符号执行</a> <a href="/tags/USENIX-18/" style="font-size: 15px;">USENIX'18</a> <a href="/tags/防护/" style="font-size: 15px;">防护</a> <a href="/tags/ACM-CCS-18/" style="font-size: 15px;">ACM CCS'18</a> <a href="/tags/fuzzing/" style="font-size: 15px;">fuzzing</a> <a href="/tags/综述/" style="font-size: 15px;">综述</a> <a href="/tags/Lacking-Recheck-Bugs/" style="font-size: 15px;">Lacking-Recheck Bugs</a> <a href="/tags/Kernels/" style="font-size: 15px;">Kernels</a> <a href="/tags/机器学习/" style="font-size: 15px;">机器学习</a> <a href="/tags/2017年/" style="font-size: 15px;">2017年</a> <a href="/tags/测试输入生成/" style="font-size: 15px;">测试输入生成</a> <a href="/tags/IOT/" style="font-size: 15px;">IOT</a> <a href="/tags/S-P-19/" style="font-size: 15px;">S&P'19</a> <a href="/tags/2019年/" style="font-size: 15px;">2019年</a> <a href="/tags/脱壳/" style="font-size: 15px;">脱壳</a> <a href="/tags/静态符号执行、/" style="font-size: 15px;">静态符号执行、</a> <a href="/tags/逆向/" style="font-size: 15px;">逆向</a> <a href="/tags/二进制分析工具/" style="font-size: 15px;">二进制分析工具</a> <a href="/tags/科研/" style="font-size: 15px;">科研</a> <a href="/tags/二进制反汇编/" style="font-size: 15px;">二进制反汇编</a> <a href="/tags/静态重写技术/" style="font-size: 15px;">静态重写技术</a> <a href="/tags/NDSS-18/" style="font-size: 15px;">NDSS'18</a> <a href="/tags/内核/" style="font-size: 15px;">内核</a> <a href="/tags/USENIX-17/" style="font-size: 15px;">USENIX'17</a> <a href="/tags/CFI/" style="font-size: 15px;">CFI</a> <a href="/tags/AsiaCCS-18/" style="font-size: 15px;">AsiaCCS'18</a> <a href="/tags/2016年/" style="font-size: 15px;">2016年</a> <a href="/tags/评估/" style="font-size: 15px;">评估</a> <a href="/tags/适应性函数/" style="font-size: 15px;">适应性函数</a> <a href="/tags/马尔科夫链/" style="font-size: 15px;">马尔科夫链</a> <a href="/tags/PCFG/" style="font-size: 15px;">PCFG</a> <a href="/tags/深度学习/" style="font-size: 15px;">深度学习</a> <a href="/tags/reinforcement-learning/" style="font-size: 15px;">reinforcement learning</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/堆叠RNN/" style="font-size: 15px;">堆叠RNN</a> <a href="/tags/2019/" style="font-size: 15px;">2019</a> <a href="/tags/污点分析/" style="font-size: 15px;">污点分析</a> <a href="/tags/LAVA/" style="font-size: 15px;">LAVA</a> <a href="/tags/梯度下降算法/" style="font-size: 15px;">梯度下降算法</a> <a href="/tags/S-P-18/" style="font-size: 15px;">S&P'18</a> <a href="/tags/LLVM/" style="font-size: 15px;">LLVM</a> <a href="/tags/可利用性判定/" style="font-size: 15px;">可利用性判定</a> <a href="/tags/Word2Vec/" style="font-size: 15px;">Word2Vec</a> <a href="/tags/数据挖掘/" style="font-size: 15px;">数据挖掘</a> <a href="/tags/漏洞检测/" style="font-size: 15px;">漏洞检测</a> <a href="/tags/源代码/" style="font-size: 15px;">源代码</a> <a href="/tags/pin/" style="font-size: 15px;">pin</a> <a href="/tags/静态分析/" style="font-size: 15px;">静态分析</a> <a href="/tags/动态分析/" style="font-size: 15px;">动态分析</a> <a href="/tags/CFG/" style="font-size: 15px;">CFG</a> <a href="/tags/NDSS-17/" style="font-size: 15px;">NDSS'17</a> <a href="/tags/神经网络/" style="font-size: 15px;">神经网络</a> <a href="/tags/Fuzzing/" style="font-size: 15px;">Fuzzing</a> <a href="/tags/S-P‘17/" style="font-size: 15px;">S&P‘17</a> <a href="/tags/SSL-TLS/" style="font-size: 15px;">SSL/TLS</a> <a href="/tags/主动学习/" style="font-size: 15px;">主动学习</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><!--if theme.baidusitemap--><!--  a(href=config.root+"baidusitemap.xml")= __("baidusitemap")--><!--  |  |  --><!--if theme.feed--><!--  a(href=config.root+"atom.xml")= __("rss")--><!--  |  |  --><!--a(href=config.root+"about/")= __("about")--></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">yama0xff.</a></span><!--span  Theme by--><!--  a(rel='nofollow', target='_blank', href='https://github.com/chaooo/hexo-theme-BlueLake')  BlueLake.--><!--if theme.busuanzi == true--><!-- span  Count by--><!--    a(href="http://busuanzi.ibruce.info/")  busuanzi.--></p><p> <span>Powered by <a rel="nofollow" target="_blank" href="https://hexo.io">Hexo</a></span><span> & Hosted by </span><a rel="nofollow" target="_blank" href="https://github.com/wtwofire">Github</a></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?33fc02326009882ae433a2c617961e1d";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script></body></html>